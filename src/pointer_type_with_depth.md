# 深さ付きポインタ型

Micの大きな、そして、固有な特徴は深さ付きポインタ型の導入です。ここでいう深さとはポインタが参照している変数が定義された複合文、すなわちブロック文の深さです。深さ付きポインタ型の変数には、そのポインタ型の深さが指し示す深さのブロックで定義された変数のアドレスしか格納できません。つまり、ほかの深さのブロックで定義された変数は一切格納できないのです。
```c
using p {
    int x = 0;
    using q {
        int p* p1 = &x; // ok!
        int q* p2 = &x; // error: the type of &x is int p*, which is incompatible with int q*, the type of p2 
    }
}
```

Micではこのようにして、あるポインタ型は必ず、その深さ付きポインタ型内で指定された深さと同じ深さのブロックで定義された変数のみを指し示すポインタ型であるということを保証します。つまりMicの原則として、異なる深さのブロック文で定義された変数を、同一のポインタ変数が複数参照する可能性があるという状況は許さないのです。こうしてMicでは、任意のポインタ変数は、`mi_free`関数によって早期解放されない限り、型が同じであれば寿命も同じであるということを保証します。
また、任意のブロック文で定義された深さ識別子はブロック文のスコープルールにより決してそれより外側のブロック文から利用できません。そのため、任意のブロック文において利用できる深さ識別子は、自分自身かそれより浅い深さで定義された深さ識別子であることが保証されます。
つまりMicの型システムは、自分が定義された深さと同じかそれより浅い深さで定義された変数を参照するポインタ型しか表現できないように制限されています。
これによって、Micではどの深さ付きポインタ型の変数も自分と同じ寿命かそれよりも長い寿命の変数を参照するということが自動的に保障されています。参照先の変数が`mi_free`関数などで解放されない限りは、参照元の変数が生きている間、参照先の変数もずっと生きています。この事実とのちの章で学ぶMicの所有権システムにより、Micは、いわゆるdangling pointerとして知られるメモリ安全性の問題やポインタの二重開放を静的に防ぐことを可能にします。